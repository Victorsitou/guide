{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Hello there! The purpose of this guide is to make your journey with disnake easier. disnake is a fork of discord.py Whether you're getting into Discord bots from scratch, or rewriting your bot from another library, this guide will fulfil and teach concepts such as: How to get started on working with bots; How to create and organize commands; Working with databases (such as sqlite and mongodb (pymongo) ); Using the AutoShardedClient class to shard our bot; A plethora of examples with popular topics along with in-depth explanation, and much more!","title":"Introduction"},{"location":"#introduction","text":"Hello there! The purpose of this guide is to make your journey with disnake easier. disnake is a fork of discord.py Whether you're getting into Discord bots from scratch, or rewriting your bot from another library, this guide will fulfil and teach concepts such as: How to get started on working with bots; How to create and organize commands; Working with databases (such as sqlite and mongodb (pymongo) ); Using the AutoShardedClient class to shard our bot; A plethora of examples with popular topics along with in-depth explanation, and much more!","title":"Introduction"},{"location":"links-credits/","text":"Links and credits \u00b6","title":"Links and credits"},{"location":"links-credits/#links-and-credits","text":"","title":"Links and credits"},{"location":"migrating-from-dpy/","text":"Migrating from discord.py \u00b6 In this guide we will try to explain the differences between discord.py and disnake, and ways to rewrite your code to disnake. Differences \u00b6 As you probably know, discord.py has been discontinued, and because of that, disnake developers and contributors committed to keep the Discord API wrapper for Python alive. discord.py 2.0 had major changes, and that's why if you are not using that version, we recommend you to read this page which collected all the major changes that version had. Rewrite \u00b6 If you want to rewrite your code from discord.py to disnake, this will require some not so difficult changes. Here are three ways to rewrite your code. Requirements \u00b6 Before we start, you must uninstall discord library, you can do it with the following command: Windows macOS Linux py -3 -m pip uninstall discord python3 -m pip uninstall discord python3 -m pip uninstall discord We do this to prevent conflicts with the disnake library. Also don't forget to install disnake, you can follow this guide to install it. Once you have those two requirements ready, let's continue with the three ways to rewrite your code from discord.py to disnake: Replace every discord to disnake : First of all, import disnake into your code: import disnake from disnake.ext import commands Don't forget to delete the lines where you import discord . Then with your favorite editor, replace every discord you have in your code with disnake . Note Please, if you have problems with your code after doing this way, try to read this page which has a list of major changes or ask us on our Discord server . Import disnake as discord: Import disnake as discord into your code: import disnake as discord from disnake.ext import commands Don't forget to delete the lines where you import discord . Note Please, if you have problems with your code after doing this way, try to read this page which has a list of major changes or ask us on our Discord server . Use discord shim: First of all, you must install the discord shim, you can do it with the following command: Windows macOS Linux py -3 -m pip install disnake[discord] python3 -m pip install disnake[discord] python3 -m pip install disnake[discord] Then, import the discord shim: import discord from discord.ext import commands The discord shim allows us to use disnake without the need to import it directly, nor import it as discord . Warning We don't recommend using the shim, please prefer to use one of the two ways already mentioned. And that's it! Since disnake is a fork of discord.py, it has a lot of similarities, but we recommend you to always run your code to fix possible bugs.","title":"Migrating from discord.py"},{"location":"migrating-from-dpy/#migrating-from-discordpy","text":"In this guide we will try to explain the differences between discord.py and disnake, and ways to rewrite your code to disnake.","title":"Migrating from discord.py"},{"location":"migrating-from-dpy/#differences","text":"As you probably know, discord.py has been discontinued, and because of that, disnake developers and contributors committed to keep the Discord API wrapper for Python alive. discord.py 2.0 had major changes, and that's why if you are not using that version, we recommend you to read this page which collected all the major changes that version had.","title":"Differences"},{"location":"migrating-from-dpy/#rewrite","text":"If you want to rewrite your code from discord.py to disnake, this will require some not so difficult changes. Here are three ways to rewrite your code.","title":"Rewrite"},{"location":"migrating-from-dpy/#requirements","text":"Before we start, you must uninstall discord library, you can do it with the following command: Windows macOS Linux py -3 -m pip uninstall discord python3 -m pip uninstall discord python3 -m pip uninstall discord We do this to prevent conflicts with the disnake library. Also don't forget to install disnake, you can follow this guide to install it. Once you have those two requirements ready, let's continue with the three ways to rewrite your code from discord.py to disnake: Replace every discord to disnake : First of all, import disnake into your code: import disnake from disnake.ext import commands Don't forget to delete the lines where you import discord . Then with your favorite editor, replace every discord you have in your code with disnake . Note Please, if you have problems with your code after doing this way, try to read this page which has a list of major changes or ask us on our Discord server . Import disnake as discord: Import disnake as discord into your code: import disnake as discord from disnake.ext import commands Don't forget to delete the lines where you import discord . Note Please, if you have problems with your code after doing this way, try to read this page which has a list of major changes or ask us on our Discord server . Use discord shim: First of all, you must install the discord shim, you can do it with the following command: Windows macOS Linux py -3 -m pip install disnake[discord] python3 -m pip install disnake[discord] python3 -m pip install disnake[discord] Then, import the discord shim: import discord from discord.ext import commands The discord shim allows us to use disnake without the need to import it directly, nor import it as discord . Warning We don't recommend using the shim, please prefer to use one of the two ways already mentioned. And that's it! Since disnake is a fork of discord.py, it has a lot of similarities, but we recommend you to always run your code to fix possible bugs.","title":"Requirements"},{"location":"000-prerequisites/001-installing-python/","text":"Installing Python and disnake \u00b6 Installing Python \u00b6 To use disnake, you'll need to install Python . Like most other discord.py forks, disnake supports Python 3.8 or higher. Note To check if you already have Python installed on your system, you can run python --version in your terminal. If the output shows Python 3.8 or higher, you can proceed to the next step. Otherwise, continue reading this article. On Windows, you can simply install it via the .exe file, which can be downloaded from the Python website . Just open the downloaded file and follow the steps via the installer. On macOS, you can visit the Python website to download the latest version, open the package installer and follow the instructions. Alternatively, you can use Homebrew to install Python, by running brew install python On Linux, you can either direcly look for the source code on the Python website , or follow the steps on this article to determine how you should install Python. Preparing the essentials \u00b6 To use disnake, you'll need to install it via pip , which is Python's standard package manager. Since pip comes standard with Python 3.4 and above, there is no need to separately install it. However, it is recommended that you set up a new project folder. Navigate to a suitable place on your machine and create a new folder named disnake-bot (or whatever you prefer). Next you'll need to open your terminal. Opening the terminal \u00b6 Tip If you use Visual Studio Code , you can press Ctrl + ` (backtick) to open its integrated terminal. On Windows, either: Shift + Right-click inside your project directory and choose the \"Open command window here\" option Press Win + R and run cmd.exe , and then cd into your project directory On macOS, either: Open Launchpad or Spotlight and search for \"Terminal\" In your \"Applications\" folder, under \"Utilities\", open the Terminal app On Linux, you can quickly open the terminal with Ctrl + Alt + T . With the terminal open, run the python --version command to make sure you've successfully installed Python. If it outputs Python 3.8 or higher, you're good to go! Installing disnake \u00b6 Now that you've installed Python and know how to open your console and run commands, you can finally install disnake! To install the library without full voice support, you can just run the following command: Windows macOS Linux py -3 -m pip install -U disnake python3 -m pip install -U disnake python3 -m pip install -U disnake Otherwise to get voice support you should run the following command: Windows macOS Linux py -3 -m pip install -U \"disnake[voice]\" python3 -m pip install -U \"disnake[voice]\" python3 -m pip install -U \"disnake[voice]\" To install the development version, do the following: $ git clone https://github.com/DisnakeDev/disnake $ cd disnake $ python3 -m pip install -U .[voice] Info While installing voice on Linux, you must install the following packages via your favourite package manager (e.g. apt , dnf , etc.) before running the above commands: libffi-dev (or libffi-devel on some systems) python-dev (e.g. python3.6-dev for Python 3.6) And that's it! With all the necessities installed, you're almost ready to start coding your bot.","title":"Installing Python and disnake"},{"location":"000-prerequisites/001-installing-python/#installing-python-and-disnake","text":"","title":"Installing Python and disnake"},{"location":"000-prerequisites/001-installing-python/#installing-python","text":"To use disnake, you'll need to install Python . Like most other discord.py forks, disnake supports Python 3.8 or higher. Note To check if you already have Python installed on your system, you can run python --version in your terminal. If the output shows Python 3.8 or higher, you can proceed to the next step. Otherwise, continue reading this article. On Windows, you can simply install it via the .exe file, which can be downloaded from the Python website . Just open the downloaded file and follow the steps via the installer. On macOS, you can visit the Python website to download the latest version, open the package installer and follow the instructions. Alternatively, you can use Homebrew to install Python, by running brew install python On Linux, you can either direcly look for the source code on the Python website , or follow the steps on this article to determine how you should install Python.","title":"Installing Python"},{"location":"000-prerequisites/001-installing-python/#preparing-the-essentials","text":"To use disnake, you'll need to install it via pip , which is Python's standard package manager. Since pip comes standard with Python 3.4 and above, there is no need to separately install it. However, it is recommended that you set up a new project folder. Navigate to a suitable place on your machine and create a new folder named disnake-bot (or whatever you prefer). Next you'll need to open your terminal.","title":"Preparing the essentials"},{"location":"000-prerequisites/001-installing-python/#opening-the-terminal","text":"Tip If you use Visual Studio Code , you can press Ctrl + ` (backtick) to open its integrated terminal. On Windows, either: Shift + Right-click inside your project directory and choose the \"Open command window here\" option Press Win + R and run cmd.exe , and then cd into your project directory On macOS, either: Open Launchpad or Spotlight and search for \"Terminal\" In your \"Applications\" folder, under \"Utilities\", open the Terminal app On Linux, you can quickly open the terminal with Ctrl + Alt + T . With the terminal open, run the python --version command to make sure you've successfully installed Python. If it outputs Python 3.8 or higher, you're good to go!","title":"Opening the terminal"},{"location":"000-prerequisites/001-installing-python/#installing-disnake","text":"Now that you've installed Python and know how to open your console and run commands, you can finally install disnake! To install the library without full voice support, you can just run the following command: Windows macOS Linux py -3 -m pip install -U disnake python3 -m pip install -U disnake python3 -m pip install -U disnake Otherwise to get voice support you should run the following command: Windows macOS Linux py -3 -m pip install -U \"disnake[voice]\" python3 -m pip install -U \"disnake[voice]\" python3 -m pip install -U \"disnake[voice]\" To install the development version, do the following: $ git clone https://github.com/DisnakeDev/disnake $ cd disnake $ python3 -m pip install -U .[voice] Info While installing voice on Linux, you must install the following packages via your favourite package manager (e.g. apt , dnf , etc.) before running the above commands: libffi-dev (or libffi-devel on some systems) python-dev (e.g. python3.6-dev for Python 3.6) And that's it! With all the necessities installed, you're almost ready to start coding your bot.","title":"Installing disnake"},{"location":"000-prerequisites/002-creating-your-application/","text":"Creating your application \u00b6 The steps mentioned further in this markdown are essentially a copy of the steps mentioned in the docs . Therefore, you can follow the steps from either resource. Note If you have already made your bot application, you can skip this document and move on to initial-files . Creating a bot account \u00b6 In order to work with the library and the Discord API in general, we must first create a Discord Bot account. Creating a Bot account is a pretty straightforward process. Make sure you\u2019re logged on to the Discord website . Navigate to the application page . Click on the New Application button. Give the application a name and click Create . Create a Bot User by navigating to the Bot tab and clicking Add Bot . Click Yes, do it! to continue. Make sure that Public Bot is ticked if you want others to invite your bot. You should also make sure that Require OAuth2 Code Grant is unchecked unless you are developing a service that needs it. If you\u2019re unsure, then leave it unchecked . Copy the token using the Copy button. This is not the Client Secret at the General Information page. And that\u2019s it. You now have a bot account and you can login with that token. Regarding bot tokens \u00b6 Danger This section is critical, so pay close attention. It explains what your bot token is, as well as the security aspects of it. What is a token, anyway? \u00b6 It should be worth noting that the token is essentially your bot\u2019s password . You should never share this with someone else. In doing so, someone can log in to your bot and do malicious things, such as leaving servers, ban all members inside a server, or pinging everyone maliciously. Tokens look like this: OTA4MjgxMjk4NTU1MTA5Mzk2.YYzc4A.TB7Ng6DOnVDlpMS4idjGptsreFg (don't worry, we immediately reset this token before even posting it here!). If it's any shorter and looks more like this: CR8UbizwLgyES9LuHK7eIrXHbRTuqoEs , you copied your client secret instead. Make sure to copy the token if you want your bot to work! Token leak scenario \u00b6 Let's imagine that you have a bot on over 1,000 servers, and it took you many, many months of coding and patience to get it on that amount. Your token gets leaked somewhere, and now someone else has it. That person can: Spam every server your bot is on; DM spam as many users as possible; Delete as many channels as possible; Kick or ban as many server members as possible; Make your bot leave all of the servers it has joined; Access and damage the underlying infrastructure (your server). All that and much, much more. Sounds pretty terrible, right? So make sure to keep your token as safe as possible! In the initial files page of the guide, we cover how to safely store your token in a configuration file. Danger If you accidentally leaked your token, click the \u201cRegenerate\u201d button as soon as possible. This revokes your old token and re-generates a new one. Now you need to use the new token to login. Discord's system messages \u00b6 System messages are official messages that Discord sends to alert you of an account issue. These messages can range from a variety of payment issues, support ticket updates, and ToS violation warnings. You can also expect a system message if your bot token has been posted on the internet publicly, and was found by Discord. Such a message will look as follows: Warning Since we do not know the extent to which Discord searches for bot tokens, or the time taken to inform the user about where the bot was found, we recommend not fully depending on this feature. But incase your bot token is found on the internet publicly (say, on a GitHub repository ), you can expect Discord to send a system message to the account the bot is linked to. Note that Discord will never ask for your password or account token, and a system message will never request for the same. System messages from Discord will have a verified SYSTEM tag, and the bar at the bottom of the DM will mention - \"This thread is reserved for official Discord notifications\". You can read more about the authenticity of these messages in this article .","title":"Creating your application"},{"location":"000-prerequisites/002-creating-your-application/#creating-your-application","text":"The steps mentioned further in this markdown are essentially a copy of the steps mentioned in the docs . Therefore, you can follow the steps from either resource. Note If you have already made your bot application, you can skip this document and move on to initial-files .","title":"Creating your application"},{"location":"000-prerequisites/002-creating-your-application/#creating-a-bot-account","text":"In order to work with the library and the Discord API in general, we must first create a Discord Bot account. Creating a Bot account is a pretty straightforward process. Make sure you\u2019re logged on to the Discord website . Navigate to the application page . Click on the New Application button. Give the application a name and click Create . Create a Bot User by navigating to the Bot tab and clicking Add Bot . Click Yes, do it! to continue. Make sure that Public Bot is ticked if you want others to invite your bot. You should also make sure that Require OAuth2 Code Grant is unchecked unless you are developing a service that needs it. If you\u2019re unsure, then leave it unchecked . Copy the token using the Copy button. This is not the Client Secret at the General Information page. And that\u2019s it. You now have a bot account and you can login with that token.","title":"Creating a bot account"},{"location":"000-prerequisites/002-creating-your-application/#regarding-bot-tokens","text":"Danger This section is critical, so pay close attention. It explains what your bot token is, as well as the security aspects of it.","title":"Regarding bot tokens"},{"location":"000-prerequisites/002-creating-your-application/#what-is-a-token-anyway","text":"It should be worth noting that the token is essentially your bot\u2019s password . You should never share this with someone else. In doing so, someone can log in to your bot and do malicious things, such as leaving servers, ban all members inside a server, or pinging everyone maliciously. Tokens look like this: OTA4MjgxMjk4NTU1MTA5Mzk2.YYzc4A.TB7Ng6DOnVDlpMS4idjGptsreFg (don't worry, we immediately reset this token before even posting it here!). If it's any shorter and looks more like this: CR8UbizwLgyES9LuHK7eIrXHbRTuqoEs , you copied your client secret instead. Make sure to copy the token if you want your bot to work!","title":"What is a token, anyway?"},{"location":"000-prerequisites/002-creating-your-application/#token-leak-scenario","text":"Let's imagine that you have a bot on over 1,000 servers, and it took you many, many months of coding and patience to get it on that amount. Your token gets leaked somewhere, and now someone else has it. That person can: Spam every server your bot is on; DM spam as many users as possible; Delete as many channels as possible; Kick or ban as many server members as possible; Make your bot leave all of the servers it has joined; Access and damage the underlying infrastructure (your server). All that and much, much more. Sounds pretty terrible, right? So make sure to keep your token as safe as possible! In the initial files page of the guide, we cover how to safely store your token in a configuration file. Danger If you accidentally leaked your token, click the \u201cRegenerate\u201d button as soon as possible. This revokes your old token and re-generates a new one. Now you need to use the new token to login.","title":"Token leak scenario"},{"location":"000-prerequisites/002-creating-your-application/#discords-system-messages","text":"System messages are official messages that Discord sends to alert you of an account issue. These messages can range from a variety of payment issues, support ticket updates, and ToS violation warnings. You can also expect a system message if your bot token has been posted on the internet publicly, and was found by Discord. Such a message will look as follows: Warning Since we do not know the extent to which Discord searches for bot tokens, or the time taken to inform the user about where the bot was found, we recommend not fully depending on this feature. But incase your bot token is found on the internet publicly (say, on a GitHub repository ), you can expect Discord to send a system message to the account the bot is linked to. Note that Discord will never ask for your password or account token, and a system message will never request for the same. System messages from Discord will have a verified SYSTEM tag, and the bar at the bottom of the DM will mention - \"This thread is reserved for official Discord notifications\". You can read more about the authenticity of these messages in this article .","title":"Discord's system messages"},{"location":"000-prerequisites/003-inviting-your-bot/","text":"Inviting your bot \u00b6 So, you've made the bot account, but it is not actually in any server. If you want to invite your bot you must create an invite URL for it. Make sure you\u2019re logged on to the Discord website . Navigate to the application page . Click on your bot\u2019s page. Go to the OAuth2 tab. Tick the bot checkbox under scopes . If you would like to integrate slash commands and other interactions into your bot, make sure to check the applications.commands scope as well. Tick the permissions required for your bot to function under Bot Permissions . Please be aware of the consequences of requiring your bot to have the Administrator permission. Bot owners must have 2FA enabled for certain actions and permissions when added in servers that have Server-Wide 2FA enabled. Check the 2FA support page for more information. Now the resulting URL can be used to add your bot to a server. Copy and paste the URL into your browser, choose a server to invite the bot to, and click Authorize . Note The person adding the bot needs \"Manage Server\" permissions to do so. If you want to generate this URL dynamically at run-time inside your bot and using the disnake.Permissions interface, you can use disnake.utils.oauth_url() .","title":"Inviting your bot"},{"location":"000-prerequisites/003-inviting-your-bot/#inviting-your-bot","text":"So, you've made the bot account, but it is not actually in any server. If you want to invite your bot you must create an invite URL for it. Make sure you\u2019re logged on to the Discord website . Navigate to the application page . Click on your bot\u2019s page. Go to the OAuth2 tab. Tick the bot checkbox under scopes . If you would like to integrate slash commands and other interactions into your bot, make sure to check the applications.commands scope as well. Tick the permissions required for your bot to function under Bot Permissions . Please be aware of the consequences of requiring your bot to have the Administrator permission. Bot owners must have 2FA enabled for certain actions and permissions when added in servers that have Server-Wide 2FA enabled. Check the 2FA support page for more information. Now the resulting URL can be used to add your bot to a server. Copy and paste the URL into your browser, choose a server to invite the bot to, and click Authorize . Note The person adding the bot needs \"Manage Server\" permissions to do so. If you want to generate this URL dynamically at run-time inside your bot and using the disnake.Permissions interface, you can use disnake.utils.oauth_url() .","title":"Inviting your bot"},{"location":"100-getting-started/101-initial-files/","text":"Initial files \u00b6 Once you add your bot to a server , the next step is to start coding and get it online! Let's start by creating a .env file for your client token and a main file for your bot application. Creating configuration files \u00b6 As explained in the \"What is a token, anyway?\" section, your token is essentially your bot's password, and you should protect it as best as possible. This can be done through a .env file, or by using environment variables. Open your application in the Discord Developer Portal and go to the Bot page to copy your token. Using environment variables \u00b6 Environment variables are special values for your environment (e.g., terminal session, docker container, or environment variable file). You can pass these values into your code's scope so that you can use them. Note When referring to a .env file, keep in mind that you can name this file whatever you prefer. For example, the file can be named token.env or secret.env . Storing data in a .env file is a common way of keeping your sensitive values safe. Create a .env file in your project directory and paste in your token. You can access your token inside other files by using os.getenv . secret.env main.py # Each line in a .env file should hold a KEY = value pair. YOUR_BOT_TOKEN = OTA4MjgxMjk4NTU1MTA5Mzk2 . YYzc4A . TB7Ng6DOnVDlpMS4idjGptsreFg # Importing \"os\" module. import os # Getting .env value. # You can name this variable in the script however you like. YOUR_BOT_TOKEN = os . getenv ( \"YOUR_BOT_TOKEN\" ) Danger If you're using Git, you should not commit this file and should ignore it via .gitignore . You can alternatively also use the python-dotenv package to either load the env variables into the environment, or make a config dict out of the env values. load_dotenv() dotenv_values() import os from dotenv import load_dotenv load_dotenv () # Take environment variables from .env. # Using the variables in your application, which uses environment variables # (e.g. from 'os.environ()' or 'os.getenv()') # as if they came from the actual environment. YOUR_BOT_TOKEN = os . getenv ( \"YOUR_BOT_TOKEN\" ) from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # Makes a dict out of the values. # Thus, we get # config = {YOUR_BOT_TOKEN: OTA4MjgxMjk4NTU1MTA5Mzk2.YYzc4A.TB7Ng6DOnVDlpMS4idjGptsreFg} # which can be used as: YOUR_BOT_TOKEN = config [ \"YOUR_BOT_TOKEN\" ] Keep in mind that the values imported from the .env file are in string format . Therefore if you would like to, say, use them for calculations, you'll have to convert them via int() Online editors (Glitch, Heroku, Replit, etc.) While we generally do not recommend using online editors as hosting solutions, but rather invest in a proper virtual private server, these services do offer ways to keep your credentials safe as well! Please see the respective service's documentation and help articles for more information on how to keep sensitive values safe: Glitch: Storing secrets in .env Heroku: Configuration variables Replit: Secrets and environment variables Git and .gitignore \u00b6 Git is a fantastic tool to keep track of your code changes and allows you to upload progress to services like GitHub , GitLab , or Bitbucket . While this is super useful to share code with other developers, it also bears the risk of uploading your configuration files with sensitive values! You can specify files that Git should ignore in its versioning systems with a .gitignore file. Create a .gitignore file in your project directory and add the names of the files and folders you want to ignore: __pycache__/ secrets.env config.json Tip __pycache__/ has been included in .gitignore as it is simply cache that helps loading and running your script faster (this is an oversimplification). As it is of no particular importance, and is recompiled every time a change is made in the script, it is better to not commit the directory. Also, you can specify quite intricate patterns in .gitignore files, as per the requirements of your project. Check out the Git documentation on .gitignore for more information! Creating the main file \u00b6 Open your code editor and create a new file. We suggest that you save the file as main.py or bot.py , but you may name it whatever you wish. Here's the base code to get you started: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Import the necessary libraries. import disnake from disnake.ext import commands # Creating a commands.Bot() instance, and assigning it to \"bot\" bot = commands . Bot () # When the bot is ready, run this code. @bot . event async def on_ready (): print ( \"The bot is ready!\" ) # Login to Discord with the bot's token. bot . run ( YOUR_BOT_TOKEN ) This is how you create a client instance for your Discord bot and login to Discord. Open your terminal and run python3 main.py to start the process. If you see \"The bot is ready!\" after a few seconds, you're good to go! Tip After closing the process with Ctrl + C , you can press the up arrow on your keyboard to bring up the latest commands you've run in the terminal. Pressing up and then enter after closing the process is a quick way to start it up again. Resulting code \u00b6 If you want to compare your code to the code we've constructed so far, you can review it over on the GitHub repository here .","title":"Initial files"},{"location":"100-getting-started/101-initial-files/#initial-files","text":"Once you add your bot to a server , the next step is to start coding and get it online! Let's start by creating a .env file for your client token and a main file for your bot application.","title":"Initial files"},{"location":"100-getting-started/101-initial-files/#creating-configuration-files","text":"As explained in the \"What is a token, anyway?\" section, your token is essentially your bot's password, and you should protect it as best as possible. This can be done through a .env file, or by using environment variables. Open your application in the Discord Developer Portal and go to the Bot page to copy your token.","title":"Creating configuration files"},{"location":"100-getting-started/101-initial-files/#using-environment-variables","text":"Environment variables are special values for your environment (e.g., terminal session, docker container, or environment variable file). You can pass these values into your code's scope so that you can use them. Note When referring to a .env file, keep in mind that you can name this file whatever you prefer. For example, the file can be named token.env or secret.env . Storing data in a .env file is a common way of keeping your sensitive values safe. Create a .env file in your project directory and paste in your token. You can access your token inside other files by using os.getenv . secret.env main.py # Each line in a .env file should hold a KEY = value pair. YOUR_BOT_TOKEN = OTA4MjgxMjk4NTU1MTA5Mzk2 . YYzc4A . TB7Ng6DOnVDlpMS4idjGptsreFg # Importing \"os\" module. import os # Getting .env value. # You can name this variable in the script however you like. YOUR_BOT_TOKEN = os . getenv ( \"YOUR_BOT_TOKEN\" ) Danger If you're using Git, you should not commit this file and should ignore it via .gitignore . You can alternatively also use the python-dotenv package to either load the env variables into the environment, or make a config dict out of the env values. load_dotenv() dotenv_values() import os from dotenv import load_dotenv load_dotenv () # Take environment variables from .env. # Using the variables in your application, which uses environment variables # (e.g. from 'os.environ()' or 'os.getenv()') # as if they came from the actual environment. YOUR_BOT_TOKEN = os . getenv ( \"YOUR_BOT_TOKEN\" ) from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # Makes a dict out of the values. # Thus, we get # config = {YOUR_BOT_TOKEN: OTA4MjgxMjk4NTU1MTA5Mzk2.YYzc4A.TB7Ng6DOnVDlpMS4idjGptsreFg} # which can be used as: YOUR_BOT_TOKEN = config [ \"YOUR_BOT_TOKEN\" ] Keep in mind that the values imported from the .env file are in string format . Therefore if you would like to, say, use them for calculations, you'll have to convert them via int() Online editors (Glitch, Heroku, Replit, etc.) While we generally do not recommend using online editors as hosting solutions, but rather invest in a proper virtual private server, these services do offer ways to keep your credentials safe as well! Please see the respective service's documentation and help articles for more information on how to keep sensitive values safe: Glitch: Storing secrets in .env Heroku: Configuration variables Replit: Secrets and environment variables","title":"Using environment variables"},{"location":"100-getting-started/101-initial-files/#git-and-gitignore","text":"Git is a fantastic tool to keep track of your code changes and allows you to upload progress to services like GitHub , GitLab , or Bitbucket . While this is super useful to share code with other developers, it also bears the risk of uploading your configuration files with sensitive values! You can specify files that Git should ignore in its versioning systems with a .gitignore file. Create a .gitignore file in your project directory and add the names of the files and folders you want to ignore: __pycache__/ secrets.env config.json Tip __pycache__/ has been included in .gitignore as it is simply cache that helps loading and running your script faster (this is an oversimplification). As it is of no particular importance, and is recompiled every time a change is made in the script, it is better to not commit the directory. Also, you can specify quite intricate patterns in .gitignore files, as per the requirements of your project. Check out the Git documentation on .gitignore for more information!","title":"Git and .gitignore"},{"location":"100-getting-started/101-initial-files/#creating-the-main-file","text":"Open your code editor and create a new file. We suggest that you save the file as main.py or bot.py , but you may name it whatever you wish. Here's the base code to get you started: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Import the necessary libraries. import disnake from disnake.ext import commands # Creating a commands.Bot() instance, and assigning it to \"bot\" bot = commands . Bot () # When the bot is ready, run this code. @bot . event async def on_ready (): print ( \"The bot is ready!\" ) # Login to Discord with the bot's token. bot . run ( YOUR_BOT_TOKEN ) This is how you create a client instance for your Discord bot and login to Discord. Open your terminal and run python3 main.py to start the process. If you see \"The bot is ready!\" after a few seconds, you're good to go! Tip After closing the process with Ctrl + C , you can press the up arrow on your keyboard to bring up the latest commands you've run in the terminal. Pressing up and then enter after closing the process is a quick way to start it up again.","title":"Creating the main file"},{"location":"100-getting-started/101-initial-files/#resulting-code","text":"If you want to compare your code to the code we've constructed so far, you can review it over on the GitHub repository here .","title":"Resulting code"},{"location":"100-getting-started/102-creating-commands/","text":"Creating commands \u00b6 Note This page is a follow-up, and the base code used is from the previous page ( Initial files ). The code can be found on the GitHub repository here . Discord also allows developers to register slash commands , which provides users a first-class way of interacting directly with your application. These slash commands shall be covered by the guide here , in the Interactions section. A note on prefix commands \u00b6 Bot commands that are initiated when a keyword is used along with a specified prefix (such as ! or $ ) are known as prefix commands (are also often referred to as text commands ). Message Intent - Privileged It is to be noted that handling prefix commands requires the message intent , which allows the bot to get content and data of messages sent by users. This intent has recently been privileged, i.e., it needs to be manually enabled for the bot application, and its requirement will be reviewed if you eventually apply for your bot's verification. You can read more about the message intent here . Therefore, to minimize the permissions your bot has to use, we will be convering prefix commands under the Popular Topics section, and advancing with the basics of slash commands in this article; more advanced topics will be covered in the Interactions section. Registering commands \u00b6 This section covers the bare minimum to get you started with registering slash commands. Once again, you can refer to this page for an in-depth coverage of topics, including guild commands, global commands, options, option types, autocomplete and choices. Now, we shall continue with the base code used in the previous section. main.py 1 2 3 4 5 6 7 8 9 10 11 12 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) bot . run ( YOUR_BOT_TOKEN ) The first step is to use the @bot.slash_command coroutine, along with an async function in order to define the code for your slash command. Below is a script demonstrating the same (focus on the use of inter , which is short for interaction ). main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def ping ( inter ): ... bot . run ( YOUR_BOT_TOKEN ) The inter passed into the function is analogous to context, or ctx used in prefix commands - it passes through all information relative to the interaction - data regarding the user who initiated the command, as an example. It is also necessary for replying to the use of the command. Using ctx vs. inter If you have experience with coding bots with discord.py , you would be familiar with using ctx as an abbreviation for passing context into the function. This guide will primarily be using inter , as it is short for interaction and refers to disnake.ApplicationCommandInteraction() . Of course, you're open to using your preferred abbreviation in code. Registering commands in specific guilds \u00b6 Note that servers are referred to as \"guilds\" in the Discord API and disnake library. On running the above code, the slash command will be registered globally, and will be accessible on all servers the bot is in. The caveat being that global registration of slash commands can take up to 1 hour (refer to Discord's documentation ). When you're trying to test your changes to code in real time, it can be immensely useful to have the command's function update with your code changes right away. Thus, you can use the guild_ids argument for the command to be instantaneously registered in a list of specified servers. (We recommend including your separate development server in this list.) main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command ( guild_ids = [ 1234 , 5678 ]) # Your server IDs go here. async def ping ( inter ): ... bot . run ( YOUR_BOT_TOKEN ) Using test_guilds in commands.Bot() When you have multiple commands registered under the same test guilds, it is convenient to only have your guild_ids defined once. Therefore, you can use the test_guilds argument in the commands.Bot() instance instead of passing guild_ids to every single command - bot = commands . Bot ( test_guilds = [ 1234 , 5678 ]) Now that you're all set with registering the slash command, you can proceed with responding to the initiated command. Responding to commands \u00b6 You can respond to a slash command initiated by the user, using inter.response.send_message() . It is analogous to using ctx.send() , in that you can respond to the interaction with embeds, files, buttons/select menus or just plain text. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command ( guild_ids = [ 1234 , 5678 ]) async def ping ( inter ): await inter . response . send_message ( \"Pong!\" ) bot . run ( YOUR_BOT_TOKEN ) Server info command \u00b6 inter.guild refers to the guild the interaction was sent in (a Guild instance ), which exposes properties such as .name or .member_count . main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def server ( inter ): await inter . response . send_message ( f \"Server name: { inter . guild . name } \\n Total members: { inter . guild . member_count } \" ) bot . run ( YOUR_BOT_TOKEN ) Tip Refer to the Guild documentation for a list of all the available properties and methods. You could also display the date the server was created, or the server's verification level. You would do those in the same manner - use inter.guild.created_at or inter.guild.verification_level , respectively. User info command \u00b6 A \"user\" refers to a Discord user. inter.author refers to the user the interaction was sent by (a User instance in DM contexts, or a Member instance in server contexts), which exposes properties such as .name or .id . (Using just inter.author will give the user's full tag.) main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def user ( inter ): await inter . response . send_message ( f \"Your tag: { inter . author } \\n Your ID: { inter . author . id } \" ) bot . run ( YOUR_BOT_TOKEN ) Tip Refer to the User and Member documentation for a list of all the available properties and methods. And there you have it! Resulting Code \u00b6 If you want to compare your code to the code we've constructed so far, you can review it over on the GitHub repository here .","title":"Creating commands"},{"location":"100-getting-started/102-creating-commands/#creating-commands","text":"Note This page is a follow-up, and the base code used is from the previous page ( Initial files ). The code can be found on the GitHub repository here . Discord also allows developers to register slash commands , which provides users a first-class way of interacting directly with your application. These slash commands shall be covered by the guide here , in the Interactions section.","title":"Creating commands"},{"location":"100-getting-started/102-creating-commands/#a-note-on-prefix-commands","text":"Bot commands that are initiated when a keyword is used along with a specified prefix (such as ! or $ ) are known as prefix commands (are also often referred to as text commands ). Message Intent - Privileged It is to be noted that handling prefix commands requires the message intent , which allows the bot to get content and data of messages sent by users. This intent has recently been privileged, i.e., it needs to be manually enabled for the bot application, and its requirement will be reviewed if you eventually apply for your bot's verification. You can read more about the message intent here . Therefore, to minimize the permissions your bot has to use, we will be convering prefix commands under the Popular Topics section, and advancing with the basics of slash commands in this article; more advanced topics will be covered in the Interactions section.","title":"A note on prefix commands"},{"location":"100-getting-started/102-creating-commands/#registering-commands","text":"This section covers the bare minimum to get you started with registering slash commands. Once again, you can refer to this page for an in-depth coverage of topics, including guild commands, global commands, options, option types, autocomplete and choices. Now, we shall continue with the base code used in the previous section. main.py 1 2 3 4 5 6 7 8 9 10 11 12 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) bot . run ( YOUR_BOT_TOKEN ) The first step is to use the @bot.slash_command coroutine, along with an async function in order to define the code for your slash command. Below is a script demonstrating the same (focus on the use of inter , which is short for interaction ). main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def ping ( inter ): ... bot . run ( YOUR_BOT_TOKEN ) The inter passed into the function is analogous to context, or ctx used in prefix commands - it passes through all information relative to the interaction - data regarding the user who initiated the command, as an example. It is also necessary for replying to the use of the command. Using ctx vs. inter If you have experience with coding bots with discord.py , you would be familiar with using ctx as an abbreviation for passing context into the function. This guide will primarily be using inter , as it is short for interaction and refers to disnake.ApplicationCommandInteraction() . Of course, you're open to using your preferred abbreviation in code.","title":"Registering commands"},{"location":"100-getting-started/102-creating-commands/#registering-commands-in-specific-guilds","text":"Note that servers are referred to as \"guilds\" in the Discord API and disnake library. On running the above code, the slash command will be registered globally, and will be accessible on all servers the bot is in. The caveat being that global registration of slash commands can take up to 1 hour (refer to Discord's documentation ). When you're trying to test your changes to code in real time, it can be immensely useful to have the command's function update with your code changes right away. Thus, you can use the guild_ids argument for the command to be instantaneously registered in a list of specified servers. (We recommend including your separate development server in this list.) main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command ( guild_ids = [ 1234 , 5678 ]) # Your server IDs go here. async def ping ( inter ): ... bot . run ( YOUR_BOT_TOKEN ) Using test_guilds in commands.Bot() When you have multiple commands registered under the same test guilds, it is convenient to only have your guild_ids defined once. Therefore, you can use the test_guilds argument in the commands.Bot() instance instead of passing guild_ids to every single command - bot = commands . Bot ( test_guilds = [ 1234 , 5678 ]) Now that you're all set with registering the slash command, you can proceed with responding to the initiated command.","title":"Registering commands in specific guilds"},{"location":"100-getting-started/102-creating-commands/#responding-to-commands","text":"You can respond to a slash command initiated by the user, using inter.response.send_message() . It is analogous to using ctx.send() , in that you can respond to the interaction with embeds, files, buttons/select menus or just plain text. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command ( guild_ids = [ 1234 , 5678 ]) async def ping ( inter ): await inter . response . send_message ( \"Pong!\" ) bot . run ( YOUR_BOT_TOKEN )","title":"Responding to commands"},{"location":"100-getting-started/102-creating-commands/#server-info-command","text":"inter.guild refers to the guild the interaction was sent in (a Guild instance ), which exposes properties such as .name or .member_count . main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def server ( inter ): await inter . response . send_message ( f \"Server name: { inter . guild . name } \\n Total members: { inter . guild . member_count } \" ) bot . run ( YOUR_BOT_TOKEN ) Tip Refer to the Guild documentation for a list of all the available properties and methods. You could also display the date the server was created, or the server's verification level. You would do those in the same manner - use inter.guild.created_at or inter.guild.verification_level , respectively.","title":"Server info command"},{"location":"100-getting-started/102-creating-commands/#user-info-command","text":"A \"user\" refers to a Discord user. inter.author refers to the user the interaction was sent by (a User instance in DM contexts, or a Member instance in server contexts), which exposes properties such as .name or .id . (Using just inter.author will give the user's full tag.) main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import disnake from disnake.ext import commands bot = commands . Bot () @bot . event async def on_ready (): print ( \"The bot is ready!\" ) @bot . slash_command () async def user ( inter ): await inter . response . send_message ( f \"Your tag: { inter . author } \\n Your ID: { inter . author . id } \" ) bot . run ( YOUR_BOT_TOKEN ) Tip Refer to the User and Member documentation for a list of all the available properties and methods. And there you have it!","title":"User info command"},{"location":"100-getting-started/102-creating-commands/#resulting-code","text":"If you want to compare your code to the code we've constructed so far, you can review it over on the GitHub repository here .","title":"Resulting Code"},{"location":"100-getting-started/103-command-handling/","text":"Command handling \u00b6 WIP","title":"Command handling"},{"location":"100-getting-started/103-command-handling/#command-handling","text":"WIP","title":"Command handling"},{"location":"100-getting-started/104-event-handling/","text":"Event handling \u00b6 WIP","title":"Event handling"},{"location":"100-getting-started/104-event-handling/#event-handling","text":"WIP","title":"Event handling"},{"location":"200-interactions/201-interactions/","text":"What are interactions? \u00b6 WIP","title":"What are interactions?"},{"location":"200-interactions/201-interactions/#what-are-interactions","text":"WIP","title":"What are interactions?"},{"location":"200-interactions/202-slash-commands/","text":"Slash commands \u00b6 WIP Example \u00b6 This is an example of a full-fledged command taking advantage of a large amount of various features. Take this as a neat teaser for what's to come. The annotations and docstrings matter @commands . guild_permissions ( 808030843078836254 , roles = { 891619545356308481 : True }) @commands . slash_command ( default_permissions = False ) async def transfer ( self , inter : disnake . ApplicationCommandInteraction , target : disnake . Member , item : str , amount : int = commands . Param ( 10 , gt = 0 , le = 100 ), source : disnake . Member = commands . Param ( lambda inter : inter . author ), reason : str = \"\" , ): \"\"\"Transfer an item from an inventory of a member to an inventory of another member Parameters ---------- target: The member which will recieve the item item: The item to transfer amount: The amount of items to transfer source: The member from which to take to item reason: The reason for this transfer \"\"\" await inter . response . send_message ( f \"Transfered { amount } x { item } from { source . mention } to { target . mention } \" ) if reason : await inter . followup . send ( reason ) @transfer . autocomplete ( \"item\" ) async def autocomplete_item ( self , inter : disnake . ApplicationCommandInteraction , option : str , * , target : disnake . Member = None , ** kwargs : Any , ): if target is None : return {} return { item [ \"name\" ]: item [ \"id\" ] for item in get_db_items ( target . id )}","title":"Slash commands"},{"location":"200-interactions/202-slash-commands/#slash-commands","text":"WIP","title":"Slash commands"},{"location":"200-interactions/202-slash-commands/#example","text":"This is an example of a full-fledged command taking advantage of a large amount of various features. Take this as a neat teaser for what's to come. The annotations and docstrings matter @commands . guild_permissions ( 808030843078836254 , roles = { 891619545356308481 : True }) @commands . slash_command ( default_permissions = False ) async def transfer ( self , inter : disnake . ApplicationCommandInteraction , target : disnake . Member , item : str , amount : int = commands . Param ( 10 , gt = 0 , le = 100 ), source : disnake . Member = commands . Param ( lambda inter : inter . author ), reason : str = \"\" , ): \"\"\"Transfer an item from an inventory of a member to an inventory of another member Parameters ---------- target: The member which will recieve the item item: The item to transfer amount: The amount of items to transfer source: The member from which to take to item reason: The reason for this transfer \"\"\" await inter . response . send_message ( f \"Transfered { amount } x { item } from { source . mention } to { target . mention } \" ) if reason : await inter . followup . send ( reason ) @transfer . autocomplete ( \"item\" ) async def autocomplete_item ( self , inter : disnake . ApplicationCommandInteraction , option : str , * , target : disnake . Member = None , ** kwargs : Any , ): if target is None : return {} return { item [ \"name\" ]: item [ \"id\" ] for item in get_db_items ( target . id )}","title":"Example"},{"location":"200-interactions/203-buttons/","text":"Buttons \u00b6 WIP","title":"Buttons"},{"location":"200-interactions/203-buttons/#buttons","text":"WIP","title":"Buttons"},{"location":"200-interactions/204-select-menus/","text":"Select menus \u00b6 WIP","title":"Select menus"},{"location":"200-interactions/204-select-menus/#select-menus","text":"WIP","title":"Select menus"},{"location":"200-interactions/205-context-menus/","text":"Context menus \u00b6 WIP","title":"Context menus"},{"location":"200-interactions/205-context-menus/#context-menus","text":"WIP","title":"Context menus"},{"location":"300-popular-topics/301-good-practices/","text":"Good practices \u00b6 Here's a list of some good practices in disnake. Running code when a cog is loaded \u00b6 Most people are used to running everything in __init__ but that doesn't allow running async code. In this case you can overwrite the special cog_load method. class MyCog ( commands . Cog ): def __init__ ( self , bot : commands . Bot ): self . bot = bot async def cog_load ( self ): self . data = await bot . fetch_database_data () @commands . slash_command () async def command ( self , interaction : disnake . ApplicationCommandInteraction , user : disnake . User ): await interaction . response . send_message ( self . data [ user . id ]) Reloading your bot \u00b6 A one of the less known disnake features is the reload kwarg for your bot. It reloads extensions every time they are edited allowing you to test your code in real-time. This is especially useful if startup times for your bot are very slow since only one extension will be reloaded at a time. from disnake.ext import commands bot = commands . Bot ( ... , reload = True ) Warning This should be used purely for debugging. Please do not use this in production. Attaching Embed Files \u00b6 Using explicit attachment:// used to be the only way to attach a local file to an embed. Disnake abstracts this with file= kwargs. # discord.py: embed = discord . Embed ( title = \"An embed with an image\" ) embed . set_image ( url = \"attachment://image.png\" ) file = discord . File ( \"assets/image.png\" ) await channel . send ( embed = embed , file = file ) # disnake: embed = disnake . Embed ( title = \"An embed with an image\" ) embed . set_image ( file = disnake . File ( \"assets/image.png\" )) await channel . send ( embed = embed ) Converting arguments in commands \u00b6 discord.py used to have Converter classes to convert arguments if they are provided. These were however very hard to use with type-checkers because the type of the parameter is never actually the converter itself. Disnake aims to eliminate this issue by only allowing conversion of builtin types like disnake.Member , disnake.Emoji , etc. If you ever want to have your own converter you have to use the converter argument in Param # discord.py class DataConverter ( commands . Converter ): async def convert ( self , ctx : commands . Context , arg : str ): parts = arg . split ( \",\" ) return { \"a\" : parts [ 0 ], \"b\" : int ( parts [ 1 ]), \"c\" : parts [ 2 ] . lower ()} @commands . command () async def command ( self , ctx : commands . Context , data : DataConverter ): ... # disnake async def convert_data ( inter : disnake . ApplicationCommandInteraction , arg : str ): parts = arg . split ( \",\" ) return { \"a\" : parts [ 0 ], \"b\" : int ( parts [ 1 ]), \"c\" : parts [ 2 ] . lower ()} @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , data : Dict [ str , Any ] = commands . Param ( converter = convert_data ), ): ... If you absolutely want to be able to use classes you may pass in a class method class Data : def __init__ ( self , a : str , b : int , c : str ): self . a = a self . b = b self . c = c @classmethod async def from_option ( cls , inter : disnake . ApplicationCommandInteraction , arg : str ): parts = arg . split ( \",\" ) return cls ( parts [ 0 ], int ( parts [ 1 ]), parts [ 2 ] . lower ()) @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , data : Data = commands . Param ( converter = Data . from_option ), ): ... Context command targets \u00b6 Instead of using inter.target you should be using a parameter of your command. @commands . user_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , user : disnake . User ): await inter . response . send_message ( f \"Used on { user . mention } \" ) Slash command descriptions \u00b6 You may use docstrings for command and option descriptions. Everything before Parameters is the command description. Everything after Parameters are the option descriptions. @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , category : str , item : str , details : bool , ): \"\"\"Show item info Parameters ---------- category: The category to search item: The item to display details: Whether to get the details of this time \"\"\" Guild-only commands \u00b6 While disnake does provide a @commands.guild_only() decorator, it still makes you handle guild being optional in case you're using linters. To solve this you should be using GuildCommandInteraction . # before @commands . slash_command () @commands . guild_only () async def command ( inter : disnake . ApplicationCommandInteraction ): assert inter . guild is not None await inter . send ( inter . guild . name ) # after @commands . slash_command () async def command ( inter : disnake . GuildCommandInteraction ): await inter . send ( inter . guild . name )","title":"Good practices"},{"location":"300-popular-topics/301-good-practices/#good-practices","text":"Here's a list of some good practices in disnake.","title":"Good practices"},{"location":"300-popular-topics/301-good-practices/#running-code-when-a-cog-is-loaded","text":"Most people are used to running everything in __init__ but that doesn't allow running async code. In this case you can overwrite the special cog_load method. class MyCog ( commands . Cog ): def __init__ ( self , bot : commands . Bot ): self . bot = bot async def cog_load ( self ): self . data = await bot . fetch_database_data () @commands . slash_command () async def command ( self , interaction : disnake . ApplicationCommandInteraction , user : disnake . User ): await interaction . response . send_message ( self . data [ user . id ])","title":"Running code when a cog is loaded"},{"location":"300-popular-topics/301-good-practices/#reloading-your-bot","text":"A one of the less known disnake features is the reload kwarg for your bot. It reloads extensions every time they are edited allowing you to test your code in real-time. This is especially useful if startup times for your bot are very slow since only one extension will be reloaded at a time. from disnake.ext import commands bot = commands . Bot ( ... , reload = True ) Warning This should be used purely for debugging. Please do not use this in production.","title":"Reloading your bot"},{"location":"300-popular-topics/301-good-practices/#attaching-embed-files","text":"Using explicit attachment:// used to be the only way to attach a local file to an embed. Disnake abstracts this with file= kwargs. # discord.py: embed = discord . Embed ( title = \"An embed with an image\" ) embed . set_image ( url = \"attachment://image.png\" ) file = discord . File ( \"assets/image.png\" ) await channel . send ( embed = embed , file = file ) # disnake: embed = disnake . Embed ( title = \"An embed with an image\" ) embed . set_image ( file = disnake . File ( \"assets/image.png\" )) await channel . send ( embed = embed )","title":"Attaching Embed Files"},{"location":"300-popular-topics/301-good-practices/#converting-arguments-in-commands","text":"discord.py used to have Converter classes to convert arguments if they are provided. These were however very hard to use with type-checkers because the type of the parameter is never actually the converter itself. Disnake aims to eliminate this issue by only allowing conversion of builtin types like disnake.Member , disnake.Emoji , etc. If you ever want to have your own converter you have to use the converter argument in Param # discord.py class DataConverter ( commands . Converter ): async def convert ( self , ctx : commands . Context , arg : str ): parts = arg . split ( \",\" ) return { \"a\" : parts [ 0 ], \"b\" : int ( parts [ 1 ]), \"c\" : parts [ 2 ] . lower ()} @commands . command () async def command ( self , ctx : commands . Context , data : DataConverter ): ... # disnake async def convert_data ( inter : disnake . ApplicationCommandInteraction , arg : str ): parts = arg . split ( \",\" ) return { \"a\" : parts [ 0 ], \"b\" : int ( parts [ 1 ]), \"c\" : parts [ 2 ] . lower ()} @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , data : Dict [ str , Any ] = commands . Param ( converter = convert_data ), ): ... If you absolutely want to be able to use classes you may pass in a class method class Data : def __init__ ( self , a : str , b : int , c : str ): self . a = a self . b = b self . c = c @classmethod async def from_option ( cls , inter : disnake . ApplicationCommandInteraction , arg : str ): parts = arg . split ( \",\" ) return cls ( parts [ 0 ], int ( parts [ 1 ]), parts [ 2 ] . lower ()) @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , data : Data = commands . Param ( converter = Data . from_option ), ): ...","title":"Converting arguments in commands"},{"location":"300-popular-topics/301-good-practices/#context-command-targets","text":"Instead of using inter.target you should be using a parameter of your command. @commands . user_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , user : disnake . User ): await inter . response . send_message ( f \"Used on { user . mention } \" )","title":"Context command targets"},{"location":"300-popular-topics/301-good-practices/#slash-command-descriptions","text":"You may use docstrings for command and option descriptions. Everything before Parameters is the command description. Everything after Parameters are the option descriptions. @commands . slash_command () async def command ( self , inter : disnake . ApplicationCommandInteraction , category : str , item : str , details : bool , ): \"\"\"Show item info Parameters ---------- category: The category to search item: The item to display details: Whether to get the details of this time \"\"\"","title":"Slash command descriptions"},{"location":"300-popular-topics/301-good-practices/#guild-only-commands","text":"While disnake does provide a @commands.guild_only() decorator, it still makes you handle guild being optional in case you're using linters. To solve this you should be using GuildCommandInteraction . # before @commands . slash_command () @commands . guild_only () async def command ( inter : disnake . ApplicationCommandInteraction ): assert inter . guild is not None await inter . send ( inter . guild . name ) # after @commands . slash_command () async def command ( inter : disnake . GuildCommandInteraction ): await inter . send ( inter . guild . name )","title":"Guild-only commands"},{"location":"300-popular-topics/302-prefix-commands/","text":"Prefix commands \u00b6 Note This page is a follow-up, and the base code used is from the previous page ( Initial files ). The code can be found on the GitHub repository here .","title":"Prefix commands"},{"location":"300-popular-topics/302-prefix-commands/#prefix-commands","text":"Note This page is a follow-up, and the base code used is from the previous page ( Initial files ). The code can be found on the GitHub repository here .","title":"Prefix commands"}]}